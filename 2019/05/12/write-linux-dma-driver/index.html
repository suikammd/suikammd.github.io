<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Petalinux DMA驱动"><meta name="keywords" content="petalinux"><meta name="author" content="suikammd"><meta name="copyright" content="suikammd"><title>Petalinux DMA驱动 | Suikammd's Blog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#最简单的内核驱动代码示例"><span class="toc-number">1.</span> <span class="toc-text">最简单的内核驱动代码示例</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#稍微复杂的内核驱动代码示例"><span class="toc-number">2.</span> <span class="toc-text">稍微复杂的内核驱动代码示例</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#DMA基础知识"><span class="toc-number">3.</span> <span class="toc-text">DMA基础知识</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#基于Petalinux编译DMA驱动"><span class="toc-number">4.</span> <span class="toc-text">基于Petalinux编译DMA驱动</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src></div><div class="author-info__name text-center">suikammd</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">10</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">7</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Suikammd's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="post-info"><div id="post-title">Petalinux DMA驱动</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-05-12</time><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="/2019/05/12/write-linux-dma-driver/#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2019/05/12/write-linux-dma-driver/"></span></a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>计划先整理下驱动的基础知识，再介绍下设备树相关dts文件的写法。</p>
<h1 id="最简单的内核驱动代码示例"><a href="#最简单的内核驱动代码示例" class="headerlink" title="最简单的内核驱动代码示例"></a>最简单的内核驱动代码示例</h1><p>首先以最简单的内核驱动代码为例，介绍如何编写以及编译驱动代码。</p>
<p>内核驱动代码至少需要包含两个函数，init函数(insmod时被调用)、exit函数(rmmod时被调用)。</p>
<p>简单的内核驱动代码示例如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/version.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">init_mod</span> <span class="params">( <span class="keyword">void</span> )</span> <span class="comment">/* Constructor */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk ( KERN_INFO <span class="string">" Module1 start\ n "</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __<span class="function"><span class="built_in">exit</span> <span class="title">end_mod</span> <span class="params">( <span class="keyword">void</span> )</span> <span class="comment">/* Destructor */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	printk ( KERN_INFO <span class="string">" Module1 end\ n "</span>);</span><br><span class="line">&#125;</span><br><span class="line">module_init ( init_mod );</span><br><span class="line">module_exit ( end_mod );</span><br><span class="line">MODULE_LICENSE (<span class="string">" GPL "</span>);</span><br><span class="line">MODULE_AUTHOR (<span class="string">" SUIKAMMD"</span>);</span><br><span class="line">MODULE_DESCRIPTION (<span class="string">" Driver Module "</span>);</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>编译驱动需要相应的kernel headers，可以通过下面的指令安装系统的kernel header，kernel header的安装位置在/usr/src/linux。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install linux-headers-$(uname -r)</span><br></pre></td></tr></table></figure>
<p>下面是Makefile的示例，如下所示：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ifneq</span> ($&#123;KERNELRELEASE&#125;,)</span><br><span class="line">		obj-m := module.o</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	KERNEL_SOURCE := /usr/src/<span class="variable">$(header version)</span></span><br><span class="line">	PWD := <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">default:</span></span><br><span class="line">	$&#123;MAKE&#125; -C $&#123;KERNEL_SOURCE&#125; M=$&#123;PWD&#125; modules</span><br><span class="line">clean :</span><br><span class="line">	$&#123;MAKE&#125; -C $&#123;KERNEL_SOURCE&#125; M=$&#123;PWD&#125; clean</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>
<p>与编译非内核驱动代码的Makefile对比，有两点让人疑惑的地方：</p>
<ol>
<li>KERNELRELEASE是什么？</li>
<li>obj-m := module何时被执行？</li>
</ol>
<p>其实在这里，make执行了两次，一次是执行当前目录下的Makefile，一次是在<code>/usr/src/linux</code>下的Makefile。在当前目录下<code>KERNELRELEASE</code>没有被定义，因此会执行<code>else</code>下的语句，执行make不加参数的默认情况下会再执行<code>default</code>中的内容，在<code>default</code>这条语句中，通过<code>make -C</code>进行目录跳转至内核源码目录读取那里的Makefile。<code>M=${PWD}</code>表明返回当前目录从头重新开始读取当前目录的Makefile，编译内核源码文件生成对应的.o文件。从内核源码目录返回时， <code>KERNELRELEASE</code>已被定义，make将读取<code>else</code>之前的内容，联合中间文件生成.ko文件。编译完之后执行<code>insmod module.ko</code> 加载内核模块，通过<code>rm module</code>删除模块，通过 <code>dmesg</code>查看内核信息判断模块是否成功加载或删除。</p>
<p>在当前目录执行<code>make</code>之后，生成一系列文件，<code>device.ko  device.mod.c  device.mod.o  device.o modules.order  Module.symvers</code>，再执行<code>sudo insmod device.ko</code>将模块加载到内核中，通过<code>dmesg tail</code>显示最近的linux内核信息，如果输出<code>Module start</code>说明模块成功加载。之后使用<code>sudo rmmod device</code>删除该模块， 通过<code>dmesg tail</code>显示最近的linux内核信息，如果输出<code>Module end</code>说明模块成功删除。</p>
<h1 id="稍微复杂的内核驱动代码示例"><a href="#稍微复杂的内核驱动代码示例" class="headerlink" title="稍微复杂的内核驱动代码示例"></a>稍微复杂的内核驱动代码示例</h1><p>上面只是一个非常简单的示例，甚至没有将该驱动与设备进行绑定，下面给出一个完成的驱动代码示例。在编写驱动代码前，使用这条指令<code>mknod -m 0666 /dev/mydev 240 0</code>创建<code>mydev</code>设备，对应的major是240，minor是0。驱动代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/version.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mydev_open</span><span class="params">(struct inode *inode, struct file *filep)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        printk(<span class="string">"Device opened\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mydev_release</span><span class="params">(struct inode *inode, struct file *filep)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        printk(<span class="string">"Device release\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> ssize_t <span class="title">mydev_read</span><span class="params">(struct file *filep, <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> count, <span class="keyword">loff_t</span> *f_pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        printk(<span class="string">"Writing to the device...\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> ssize_t <span class="title">mydev_write</span><span class="params">(struct file *filep, <span class="keyword">const</span> <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> count, <span class="keyword">loff_t</span> *f_pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        printk(<span class="string">"Writing to the device...\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">mydev_fops</span> =</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        owner: THIS_MODULE,</span><br><span class="line">        open: mydev_open,</span><br><span class="line">        release: mydev_release,</span><br><span class="line">        read: mydev_read,</span><br><span class="line">        write: mydev_write,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">init_mydevDriver</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result;</span><br><span class="line">        <span class="keyword">if</span> ((result = register_chrdev(<span class="number">240</span>, <span class="string">"mydev"</span>, &amp;mydev_fops)) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">goto</span> fail;</span><br><span class="line">        printk(<span class="string">"my device driver loaded...\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        fail:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __<span class="function"><span class="built_in">exit</span> <span class="title">exit_mydevDriver</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        unregister_chrdev(<span class="number">240</span>, <span class="string">"mydev"</span>);</span><br><span class="line">        printk(<span class="string">"mydev driver unloaded...\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(init_mydevDriver);</span><br><span class="line">module_exit(exit_mydevDriver);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">" GPL "</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">" SUIKA "</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">" Test Driver Module "</span>);</span><br></pre></td></tr></table></figure>
<p>Makefile与上文示例几乎一致，下面给出测试代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> buffer[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> fd;</span><br><span class="line">        fd=open(<span class="string">"/dev/mydev"</span>, O_RDWR);</span><br><span class="line">        buffer[<span class="number">0</span>]=<span class="number">0x00</span>;</span><br><span class="line">        write(fd, buffer, <span class="number">1</span>);</span><br><span class="line">        read(fd, buffer);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Value : 0x%02x\n"</span>, buffer[<span class="number">0</span>]);</span><br><span class="line">        close(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面介绍了驱动代码的编写和编译，接下来介绍下xilinx的DMAENGINE和DMA的基础知识。</p>
<h1 id="DMA基础知识"><a href="#DMA基础知识" class="headerlink" title="DMA基础知识"></a>DMA基础知识</h1><p>dma一般是内核空间下使用的驱动，用户空间比较复杂。</p>
<p>DMA有两种，<code>Slave-DMA</code>、<code>Async TX</code>：</p>
<ol>
<li><p><code>Slave-DMA</code>：memory-&gt;device, device-&gt;memory, device-&gt;device</p>
<p>slave的含义是指参与DMA传输的设备，对应的”master”是DMA controller本身</p>
</li>
<li><p><code>Async TX</code>：memory-&gt;memory</p>
</li>
</ol>
<p>这里我们主要介绍slave DMA的使用方法，包括如下5个步骤，详细可以参考<a href="https://github.com/Xilinx/linux-xlnx/blob/master/Documentation/driver-api/dmaengine/client.rst" target="_blank" rel="noopener">xilinx dma slave api</a>：</p>
<ol>
<li><p>申请一个DMA channel</p>
<p>DMA channel（结构：struct dam_chan），由DMA controller（provider）提供，被consumer（client，driver，slave driver）使用，client通过<code>struct dma_chan *dma_request_chan(struct device *dev, const char *name)</code>API申请channel，通过<code>void dma_release_channel(struct dma_chan *chan)</code>API释放channle。</p>
</li>
<li><p>配置DMA channel参数</p>
<p>driver申请到DMA channel后根据实际情况及DMA controller的能力配置channel，通过API<code>int dmaengine_slave_config(struct dma_chan *chan, struct dma_slave_config *config)</code>将<code>struct dma_slave_config</code>告知DMA controller。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#struct dma_slave_config</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dma_slave_config</span> &#123;</span> </span><br><span class="line">        <span class="keyword">enum</span> dma_transfer_direction direction; </span><br><span class="line">        <span class="keyword">phys_addr_t</span> src_addr; </span><br><span class="line">        <span class="keyword">phys_addr_t</span> dst_addr; </span><br><span class="line">        <span class="keyword">enum</span> dma_slave_buswidth src_addr_width; </span><br><span class="line">        <span class="keyword">enum</span> dma_slave_buswidth dst_addr_width; </span><br><span class="line">        u32 src_maxburst; </span><br><span class="line">        u32 dst_maxburst; </span><br><span class="line">        <span class="keyword">bool</span> device_fc; </span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> slave_id; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>代码中参数介绍：</p>
<p>direction：指明传输方向 memory-&gt;device, device-&gt;memory, device-&gt;device, memory-&gt;memory</p>
<p>src_addr：读取数据位置（src为mem不需要配置）</p>
<p>dst_addr：写入数据位置（dst为mem不需要配置）</p>
<p>src_addr_width、dst_addr_width：src/dst地址的宽度</p>
<p>src_maxburst、dst_maxburst：src/dst最大可传输的burst size（DMA控制的可缓存数据量大小）</p>
<p>device_fc：决定DMA传输是否结束的模块</p>
<p>slave_id：slave通过slave_id告诉dma controller自己的身份，一般情况下非必要，只要知道src、dst、len即可。</p>
</li>
<li><p>获取传输描述</p>
<p>通过API<code>dmaengine_prep_slave_single()</code>获得描述符<code>dma_async_tx_descriptor</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dma_async_tx_descriptor</span> &#123;</span> </span><br><span class="line">         <span class="keyword">dma_cookie_t</span> cookie; </span><br><span class="line">         <span class="keyword">enum</span> dma_ctrl_flags flags; <span class="comment">/* not a 'long' to pack with cookie */</span> </span><br><span class="line">         <span class="keyword">dma_addr_t</span> phys; </span><br><span class="line">         <span class="class"><span class="keyword">struct</span> <span class="title">dma_chan</span> *<span class="title">chan</span>;</span> </span><br><span class="line">         <span class="keyword">dma_cookie_t</span> (*tx_submit)(struct dma_async_tx_descriptor *tx); </span><br><span class="line">         <span class="keyword">int</span> (*desc_free)(struct dma_async_tx_descriptor *tx); </span><br><span class="line">         dma_async_tx_callback callback; </span><br><span class="line">         <span class="keyword">void</span> *callback_param; </span><br><span class="line">         <span class="class"><span class="keyword">struct</span> <span class="title">dmaengine_unmap_data</span> *<span class="title">unmap</span>;</span> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_ASYNC_TX_ENABLE_CHANNEL_SWITCH </span></span><br><span class="line">         <span class="class"><span class="keyword">struct</span> <span class="title">dma_async_tx_descriptor</span> *<span class="title">next</span>;</span> </span><br><span class="line">         <span class="class"><span class="keyword">struct</span> <span class="title">dma_async_tx_descriptor</span> *<span class="title">parent</span>;</span> </span><br><span class="line">         <span class="keyword">spinlock_t</span> lock; </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动传输</p>
<p>获取传输描述符之后，通过<code>dmaengine_submit</code> API将描述符放到传输队列，返回唯一识别该标志符的cookie，再调用<code>dma_async_issue_pending</code>API启动传输。</p>
</li>
<li><p>等待传输结束</p>
<p>通过API<code>dma_async_is_tx_complete()</code>判断DMA事务是否完成。</p>
</li>
</ol>
<h1 id="基于Petalinux编译DMA驱动"><a href="#基于Petalinux编译DMA驱动" class="headerlink" title="基于Petalinux编译DMA驱动"></a>基于Petalinux编译DMA驱动</h1><p>请根据<a href="https://suikammd.github.io/2019/04/24/petalinux_build_based_on_xilinx_zcu104/">基于Xilinx zcu104版的petalinux移植linux（ffmpeg）</a>这边文章认真配置环境</p>
<ul>
<li><p>Pre-requisites</p>
<ol>
<li><p>A zero-copy Linux driver and a userspace interface library for Xilinx’s AXI DMA and VDMA IP blocks. These serve as bridges for communication between the processing system and FPGA programmable logic fabric, through one of the DMA ports on the Zynq processing system.</p>
<p> <code>git clone https://github.com/bperez77/xilinx_axidma.git</code></p>
</li>
</ol>
</li>
<li><p>Steps</p>
<ol>
<li><p>add hdf to ur petalinux project（这个hdf文件仅仅做了loopback，以下基于此loopback进行介绍）</p>
</li>
<li><p><code>petalinux-config --get-hw-description $(UR-HDF-PATH)</code></p>
<p><code>Image Packaging Configurations -&gt; Root filesystem type -&gt; SD card</code></p>
<p>取消勾选<code>DTG Settings-&gt;Kernel Bootargs-&gt;generate boot args automatically</code>，set bootargs to <code>earlycon console=ttyPS0,115200 clk_ignore_unused root=/dev/mmcblk0p2 rw rootwait</code></p>
</li>
<li><p><code>petalinux-build</code></p>
<p>在编译过程中，如果卡在fsbl的编译，请执行以下两条指令 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install libgtk-3-dev</span><br><span class="line">sudo apt install libgtk2.0-dev</span><br></pre></td></tr></table></figure>
</li>
<li><p>create module </p>
<ul>
<li><p><code>petalinux-create -t modules -n xilinx-axidma --enable</code></p>
</li>
<li><p>进入到git clone的文件夹路径，将所需文件拷贝到petalinux module的路径。这里涉及到三步，第一步拷贝文件，第二步删除不必要的文件，第三步是修改petalinux module文件夹的下的Makefile和.bb文件。</p>
<p>（1）将git clone下来的文件夹里的文件拷贝到petalinux module的路径<code>&lt;path/to/PetaLinux/project&gt;/project-spec/meta-user/recipes-modules/xilinx-axidma/files</code></p>
<p><code>cp -a driver/*.c driver/*.h include/axidma_ioctl.h &lt;path/to/PetaLinux/project&gt;/project-spec/meta-user/recipes-modules/xilinx-axidma/files</code> </p>
<p>（2） 删除<code>xilinx-axidma.c</code></p>
<p> <code>rm &lt;path/to/PetaLinux/project&gt;/project-spec/meta-user/recipes-modules/xilinx-axidma/files/xilinx-axidma.c</code></p>
<p>（3） 修改<code>&lt;path/to/PetaLinux/project&gt;/project-spec/meta-user/recipes-modules/xilinx-axidma/files/Makefile</code></p>
<p>删除Makefile第一行，取代为下面三行代码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">DRIVER_NAME = xilinx-axidma</span><br><span class="line"><span class="meta">$</span><span class="bash">(DRIVER_NAME)-objs = axi_dma.o axidma_chrdev.o axidma_dma.o axidma_of.o</span></span><br><span class="line">obj-m := $(DRIVER_NAME).o</span><br></pre></td></tr></table></figure>
<p> （4） 修改<code>&lt;path/to/PetaLinux/project&gt;/project-spec/meta-user/recipes-modules/xilinx-axidma/xilinx-axidma.bb</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SRC_URI = "file://Makefile \ </span><br><span class="line">           file://axi_dma.c \</span><br><span class="line">           file://axidma_chrdev.c \</span><br><span class="line">           file://axidma_dma.c \</span><br><span class="line">           file://axidma_of.c \</span><br><span class="line">           file://axidma.h \</span><br><span class="line">           file://axidma_ioctl.h \</span><br><span class="line">           file://COPYING \</span><br><span class="line">          "</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>create app</p>
<p>这里的app实现的功能是，将从千兆拿到的视频i帧转为yuv格式(基于ffmpeg)送到pl端，再将从pl端返回的结果送回内网的服务器。</p>
</li>
<li><p>change the system-user.dtsi according the pl.dtsi.</p>
<p>（1） 根据之前petalinux-build生成的<code>pl.dtsi</code>，将其中的内容全部复制到<code>system-conf.dtsi</code>，这两个文件的地址均在<code>&lt;path/to/PetaLinux/project&gt;/components/plnx_workspace/device-tree/device-tree</code>，按理说这部分复制进system-user.dtsi也可以，<code>&lt;path/to/PetaLinux/project&gt;/components/plnx_workspace/device-tree/device-tree</code>这个目录下的文件一般是自动生成的。</p>
<p>（2） 同时删除<code>system-top.dtsi</code>最后一行<code>#include system-user.dtsi</code></p>
<p>（3） 修改system-user.dtsi（位置<code>/project-spec/meta-user/recipes-bsp/device-tree/files/”</code>），加入以下内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/ &#123;</span><br><span class="line">        axidma_chrdev: axidma_chrdev@0 &#123;</span><br><span class="line">        compatible = "xlnx,axidma-chrdev";</span><br><span class="line">        dmas = &lt;&amp;axi_dma_0 0 &amp;axi_dma_0 1&gt;;</span><br><span class="line">        dma-names = "tx_channel", "rx_channel";</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>petalinux-build</code></p>
</li>
<li><p><code>petalinux-package --boot --fsbl ./images/linux/zynqmp_fsbl.elf --fpga ./images/linux/system.bit  --pmufw ./images/linux/pmufw.elf --u-boot</code>，生成的文件<code>BOOT.bin、image.ub</code>位于<code>&lt;path/to/PetaLinux/project&gt;/images/linux/</code>下</p>
</li>
</ol>
</li>
</ul>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">suikammd</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://suikammd.github.io/2019/05/12/write-linux-dma-driver/">https://suikammd.github.io/2019/05/12/write-linux-dma-driver/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/petalinux/">petalinux</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2019/05/29/AWS-Save-Money/"><i class="fa fa-chevron-left">  </i><span>AWS-Save-Money</span></a></div><div class="next-post pull-right"><a href="/2019/04/27/aarch64-cross-compile/"><span>aarch64 交叉编译</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'https://suikammd.github.io/2019/05/12/write-linux-dma-driver/';
  this.page.identifier = '2019/05/12/write-linux-dma-driver/';
  this.page.title = 'Petalinux DMA驱动';
}
var d = document, s = d.createElement('script');
s.src = "https://" + 'suikammd' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script><script id="dsq-count-scr" src="https://suikammd.disqus.com/count.js" async></script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2020 By suikammd</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>